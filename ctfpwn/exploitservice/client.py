#!/usr/bin/env python3
"""
A client for exploitservice. It can be used to either enable or
disable existing exploits. If the exploit does not yet exists,
it will be created. So this is also a way to add new exploits
to the database.
"""
import sys
import argparse
import asyncio

#from .exploitdb import ExploitDB
from ctfpwn.db import CtfDb


async def update_exploit(SERVICE, EXPLOIT, PORT, ENABLED):
    db = await CtfDb.create()
    result = await db.update_exploit(SERVICE, EXPLOIT, PORT, ENABLED)
    if result['nModified'] > 0:
        print('Updated exploit')
    else:
        print('Nothing changed')


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('service', metavar='<service>')
    parser.add_argument('exploit', metavar='<exploit>')
    parser.add_argument('port', type=int, metavar='<port>')
    parser.add_argument('enable', metavar='<enable>', choices=(
                                'true', 'True', '1', 'TRUE',
                                'false', 'False', '0', 'FALSE'
                                ))

    args = parser.parse_args()

    SERVICE = args.service
    EXPLOIT = args.exploit
    PORT = args.port

    # if not os.path.isfile(EXPLOIT):
    #     print('Not a valid file: {}'.format(EXPLOIT))
    #     print('Please provide the absolute path to the exploit executable.')
    #     return 1

    # if not os.path.isabs(EXPLOIT):
    #     EXPLOIT = os.path.abspath(EXPLOIT)

    if args.enable in [1, 'TRUE', 'True', 'true', True]:
        ENABLED = True
    elif args.enable in [0, 'FALSE', 'False', 'false', False]:
        ENABLED = False

    try:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(update_exploit(SERVICE, EXPLOIT, PORT, ENABLED))
        return 0
    except Exception as e:
        print(e)
        raise e
        return 1
    finally:
        loop.close()

if __name__ == '__main__':
    sys.exit(main())
