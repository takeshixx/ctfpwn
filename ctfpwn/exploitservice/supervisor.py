import asyncio
import functools
import logging
import os
import pathlib
import random
import re
import time
import ipaddress

from helperlib.logging import scope_logger

from ctfpwn.shared import Flag
from .worker import ExploitWorkerProtocol

log = logging.getLogger(__name__)

# Global instance to grep for flags, e.g.JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=
FLAG_GREP = re.compile(br"(\w{31}=)")


@scope_logger
class Supervisor:
    """The supervisor manages all running exploit instances."""
    def __init__(self, db, config, loop=None, *args, **kwargs):
        self.db = db
        self.config = config
        self.loop = loop or asyncio.get_event_loop()
        self.sem = asyncio.Semaphore(100)
        self.running_exploits = {}

    def start(self, interval):
        async def _run(interval):
            while True:
                await self.supervisor_callback()
                await asyncio.sleep(interval)
        self.loop.create_task(_run(interval))

    def __repr__(self):
        return object.__repr__(self)

    async def start_exploit(self, service, exploit, target, port):
        """Start an exploit worker process."""
        exit_future = self.loop.create_future()
        cmd = [exploit, target, str(int(port))]
        self.log.debug('Starting %r', cmd)

        protocol_factory = lambda: ExploitWorkerProtocol(exit_future, cmd)
        transport, protocol = await self.loop.subprocess_exec(protocol_factory, *cmd, stdin=None)
        process_started = int(time.time())

        # Safe some information in an instance variable, might be useful at some point in time.
        self.running_exploits[transport.get_pid()] = {'process': transport, 'started': process_started}

        # Add callback function which will be called when the exploits ran successfully.
        exit_future.add_done_callback(
            functools.partial(
                self.exploit_callback,
                transport.get_pid(),
                service,
                exploit,
                target,
                port,
                process_started
            )
        )
        self.log.debug('Register kill timeout (%d) for %d', self.config.get('kill_exploit_after'), transport.get_pid())
        # Kill exploits after KILL_EXPLOIT_AFTER seconds.
        self.loop.call_later(self.config.get('kill_exploit_after'), functools.partial(self.stop_exploit, transport))
        return exit_future

    def stop_exploit(self, transport):
        """Stop an exploit worker process if it's not already finished."""
        if transport.get_returncode():
            return

        self.log.debug('Kill %d', transport.get_pid())
        try:
            transport.kill()
            transport.close()
        except OSError:
            self.log.debug('Killing %d failed!', transport.get_pid())

        self.running_exploits.pop(transport.get_pid(), None)

    def exploit_callback(self, pid, service, exploit, target, port, exploit_started, future, *args, **kwargs):
        """The callback that will be called when a exploits has been
        executed without errors. Once the output (STDOUT) contains
        flags, they will be added to the database."""
        exploit_finished = int(time.time())
        self.log.debug('Finished successfully: %d', pid)

        data = self.running_exploits.pop(pid, None)
        # close transport
        if data:
            data['process'].close()

        if future.exception() is not None:
            # TODO: is there output even if the exploit threw an exception? maybe check for flags
            self.loop.create_task(
                self.db.insert_run(service, exploit, target, port, 'FAILED', exploit_started, exploit_finished))
            return

        output = future.result()

        if (not len(self.running_exploits) % 10):
            self.log.info('[QUEUE] [RUNNING %d]', len(self.running_exploits))

        # output is bytes here
        if FLAG_GREP.findall(output):
            flags = 0
            for flag in FLAG_GREP.findall(output):
                if not flag:
                    continue
                flags += 1
                # decode to unicode before inserting flag
                _flag = Flag(service, target, flag.decode('utf-8', errors='replace'))
                self.loop.create_task(self.db.insert_new_flag(_flag))
            self.log.debug('[%s] [EXPLOIT %s] Returned %d flags', service, exploit, flags)
        else:
            self.log.error('[%s] [NO FLAGS RETURNED] [EXPLOIT %s]',
                service,
                exploit
            )

    def supervisor_cleaner(self):
        """Periodically clean the running PIDs. This function will
        be called each SUPERVISOR_CLEAN_WORKERS_INTERVAL seconds."""
        self.log.debug('started supervisor_cleaner()')
        for pid in self.running_exploits.keys():
            try:
                os.kill(pid, 0)
            except OSError:
                self.running_exploits.pop(pid, None)

        self.log.debug('finished supervisor_cleaner()')

    async def supervisor_callback(self):
        """This function will be called periodically to queue execution
        of all available exploits."""
        self.log.debug('started supervisor_callback()')
        t0 = time.time()
        self.log.info('[QUEUE] [supervisor_callback()]')
        if len(self.running_exploits):
            self.log.info('[QUEUE] [STILL RUNNING EXPLOIT PROCESSES %d]', len(self.running_exploits))

        exploits = await self.db.select_exploits()
        targets = await self.get_targets()

        if exploits:
            self.log.info('Found %d exploits', len(exploits))
        else:
            self.log.info('No exploits available')
            return

        if targets:
            self.log.info('Found %d alive targets', len(targets))
        else:
            self.log.info('No alive targets found!')
            return

        random.shuffle(exploits)
        random.shuffle(targets)
        futures = []
        services = set()
        for exploit in exploits:
            if exploit['enabled']:
                _fp = pathlib.Path(exploit['exploit'])
                if not _fp.is_file():
                    self.log.error('[EXPLOITS] [Could not find exploit %s]', exploit['exploit'])
                    continue

                services.add(exploit['service'])

                for target in targets:
                    async def run(*args):
                        async with self.sem:
                            return await self.start_exploit(*args)

                    futures.append(asyncio.ensure_future(
                        run(
                            exploit['service'],
                            exploit['exploit'],
                            str(target),
                            exploit['port']
                        )
                    ))

        # Log a message whenever a batch of exploits was executed in a new tick.
        future = asyncio.gather(*futures)
        future.add_done_callback(functools.partial(self.tick_started, services=services))

        # Call the cleaner function which removes already exited processes from the self.running_exploits list.
        self.loop.call_later(self.config.get('supervisor_clean_workers_interval'), self.supervisor_cleaner)

        self.log.debug('finished supervisor_callback() took %f', time.time() - t0)

    def tick_started(self, future, services):
        # if future.exception():
        #     return

        results = future.result()
        if results:
            self.log.info('[QUEUE] [ADDED %d] [SERVICES %d]', len(results), len(services))

    async def get_targets(self):
        """This function should return a list of IP addresses to execute exploits against
        in a new batch."""
        targets = await self.db.select_alive_targets()

        if targets:
            _targets = []
            for _target in targets:
                _targets.append(_target['host'])
            return _targets
        else:
            self.log.info('No alive targets in database, trying full range...')
            network = ipaddress.ip_network(self.config.get('ctf_network'), strict=False)
            return list(network.hosts())
