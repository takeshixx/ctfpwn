import asyncio
import functools
import logging
import os
import pathlib
import random
import re
import time

from helperlib.logging import scope_logger

from ctfpwn.flagservice import Flag
from .targets import TARGETS
from .worker import ExploitWorkerProtocol

log = logging.getLogger(__name__)

# The network range where teams are located, needs to be adjusted
CTF_NETWORK = '10.60.1.0/23'
CTF_OWN_BOX = '10.60.42.2'

# Maximum amount of concurrent running exploits.
MAX_CONCURRENT_WORKERS = 2048

# Start of the CTF (November 21, 2015 at 10:00 UTC)
GAME_START = 1448100000

# The time when the network should be open (1hour after CTF has started)
NETWORK_OPEN = GAME_START + 60 * 60

# A CTF round will be ~2min
CTF_TICK = 60 * 2

# Check alive hosts every x minutes
CTF_TARGET_ALIVE_INTERVAL = 60 * 3

# If an exploit is still running after x seconds, kill it with fire!
KILL_EXPLOIT_AFTER = 120

SUPERVISOR_CLEAN_WORKERS_INTERVAL = 120

# Global instance to grep for flags, e.g.JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=
FLAG_GREP = re.compile(br"(\w{31}=)")


@scope_logger
class Supervisor:
    """
    The supervisor manages all running exploit instances.
    """
    def __init__(self, db, *args, **kwargs):
        self.db = db
        self.sem = asyncio.Semaphore(100)
        self.running_exploits = {}

    def start(self, interval, loop=None):
        if loop is None:
            loop = asyncio.get_event_loop()

        async def _run(interval):
            while True:
                await self.supervisor_callback()
                await asyncio.sleep(interval)

        self._loop = loop
        loop.create_task(_run(interval))

    def __repr__(self):
        return object.__repr__(self)

    async def start_exploit(self, service, exploit, target, port):
        """
        Start an exploit worker process.
        """
        exit_future = self._loop.create_future()
        cmd = [exploit, target, str(int(port))]
        self.log.debug('Starting %r', cmd)

        protocol_factory = lambda: ExploitWorkerProtocol(exit_future, cmd)
        transport, protocol = await self._loop.subprocess_exec(protocol_factory, *cmd, stdin=None)
        process_started = int(time.time())

        # Safe some information in an instance variable, might be useful at some point in time.
        self.running_exploits[transport.get_pid()] = {'process': transport, 'started': process_started}

        # Add callback function which will be called when the exploits ran successfully.
        exit_future.add_done_callback(
            functools.partial(
                self.exploit_success_callback,
                transport.get_pid(),
                service,
                exploit,
                target,
                port,
                process_started
            )
        )
        # Add an error callback that will be called when the exploit did not finish successful.
        # This will be called e.g. when the exploit fails to properly catch exceptions.
        exit_future.add_done_callback(
            functools.partial(
                self.exploit_failed_callback,
                transport.get_pid(),
                service,
                exploit,
                target,
                port,
                process_started
            )
        )
        self.log.debug('Register kill timeout (%d) for %d', KILL_EXPLOIT_AFTER, transport.get_pid())
        # Kill exploits after KILL_EXPLOIT_AFTER seconds.
        self._loop.call_later(KILL_EXPLOIT_AFTER, functools.partial(self.stop_exploit, transport))
        return exit_future

    def stop_exploit(self, transport):
        """
        Stop an exploit worker process if it's not already finished.
        """
        if transport.get_returncode():
            return

        self.log.debug('Kill %d', transport.get_pid())
        try:
            transport.kill()
            transport.close()
        except OSError:
            self.log.debug('Killing %d failed!', transport.get_pid())

        self.running_exploits.pop(transport.get_pid(), None)

    def exploit_failed_callback(self, pid, service, exploit, target, port, exploit_started, future, *args, **kwargs):
        """
        This callback will be called when there was an error during the
        execution of an exploit. It will just add a run to the database
        with state FAILED.

        :type reason:
        :type pid: int
        :type service: str
        :type exploit: str
        :type target: str
        :type port: int
        :type exploit_started: bool
        """
        if future.exception() is None:
            return

        reason = future.exception()

        data = self.running_exploits.pop(pid, None)
        # close transport
        if data:
            data['process'].close()
        exploit_finished = int(time.time())
        self._loop.create_task(
            self.db.insert_run(service, exploit, target, port, 'FAILED', exploit_started, exploit_finished)
        )

        log.error('[%s] [EXPLOIT %s] [%s]',
            service,
            exploit,
            reason
        )

    def exploit_success_callback(self, pid, service, exploit, target, port, exploit_started, future, *args, **kwargs):
        """
        The callback that will be called when a exploits has been executed
        without errors. Once the output (STDOUT) contains flags, they
        will be added to the database.

        :type output: bytes
        :type pid: int
        :type service: str
        :type exploit: str
        :type target: str
        :type port: int
        :type exploit_started: bool
        """
        if future.exception() is not None:
            return

        output = future.result()

        # self.log.debug('Finished successfully: %d', pid)

        data = self.running_exploits.pop(pid, None)
        # close transport
        if data:
            data['process'].close()

        if (not len(self.running_exploits) % 10):
            self.log.info('[QUEUE] [RUNNING %d]', len(self.running_exploits))

        exploit_finished = int(time.time())
        self._loop.create_task(
            self.db.insert_run(service, exploit, target, port, 'SUCCESS', exploit_started, exploit_finished)
        )

        # output is bytes here
        if FLAG_GREP.findall(output):
            flags = 0
            for flag in FLAG_GREP.findall(output):
                if not flag:
                    continue
                flags += 1
                # decode to unicode before inserting flag
                _flag = Flag(service, target, flag.decode('utf-8', errors='replace'))
                self._loop.create_task(
                    self.db.insert_new_flag(_flag)
                )
            self.log.debug('[%s] [EXPLOIT %s] Returned %d flags', service, exploit, flags)
        else:
            self.log.error('[%s] [NO FLAGS RETURNED] [EXPLOIT %s]',
                service,
                exploit
            )

    def supervisor_cleaner(self):
        """
        Periodically clean the running PIDs. This function will be called each SUPERVISOR_CLEAN_WORKERS_INTERVAL
        seconds.
        """
        self.log.debug('started supervisor_cleaner()')
        for pid in self.running_exploits.keys():
            try:
                os.kill(pid, 0)
            except OSError:
                self.running_exploits.pop(pid, None)

        self.log.debug('finished supervisor_cleaner()')

    async def supervisor_callback(self):
        """
        This function will be called periodically to queue execution
        of all available exploits.
        """
        self.log.debug('started supervisor_callback()')
        t0 = time.time()
        self.log.info('[QUEUE] [supervisor_callback()]')
        if len(self.running_exploits):
            self.log.info('[QUEUE] [STILL RUNNING EXPLOIT PROCESSES %d]', len(self.running_exploits))

        exploits = await self.db.select_exploits().to_list(None)
        targets = await self.get_targets()

        if exploits:
            self.log.info('Found %d exploits', len(exploits))
        else:
            self.log.info('No exploits available')
            return

        if targets:
            self.log.info('Found %d alive targets', len(targets))
        else:
            self.log.info('No alive targets found!')
            return

        random.shuffle(exploits)
        random.shuffle(targets)
        futures = []
        services = set()
        for exploit in exploits:
            if exploit['enabled']:
                _fp = pathlib.Path(exploit['exploit'])
                if not _fp.is_file():
                    self.log.error('[EXPLOITS] [Could not find exploit %s]', exploit['exploit'])
                    continue

                services.add(exploit['service'])

                for target in targets:
                    async def run(*args):
                        async with self.sem:
                            return await self.start_exploit(*args)

                    futures.append(asyncio.ensure_future(
                        run(
                            exploit['service'],
                            exploit['exploit'],
                            str(target),
                            exploit['port']
                        )
                    ))

        # Log a message whenever a batch of exploits was executed in a new tick.
        future = asyncio.gather(*futures)
        future.add_done_callback(functools.partial(self.tick_started, services=services))

        # Call the cleaner function which removes already exited processes from the self.running_exploits list.
        self._loop.call_later(SUPERVISOR_CLEAN_WORKERS_INTERVAL, self.supervisor_cleaner)

        self.log.debug('finished supervisor_callback() took %f', time.time() - t0)

    def tick_started(self, future, services):
        # if future.exception():
        #     return

        results = future.result()
        if results:
            self.log.info('[QUEUE] [ADDED %d] [SERVICES %d]', len(results), len(services))

    async def get_targets(self):
        """This function should return a list of IP addresses to execute exploits against
        in a new batch."""
        targets = await self.db.select_alive_targets().to_list(None)

        if targets:
            _targets = []
            for _target in targets:
                _targets.append(_target['host'])
            return _targets
        else:
            self.log.info('No alive targets in database, trying full range...')
            return TARGETS
