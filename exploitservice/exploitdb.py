"""This module provides an interface to the database and
anything that is needed to handle exploits."""
import time
import logging
# import asyncio
import motor.motor_asyncio
import pymongo
from helperlib.logging import scope_logger

log = logging.getLogger(__name__)

LOG_LEVEL_STAT = logging.INFO + 1
logging.addLevelName(LOG_LEVEL_STAT, 'STATISTIC')

# Maximum amount of simultaneous connections to the database
SERVICE_MONGO_POOLSIZE = 100


class Flag():
    """
    A class that represents flags, as parsed from incoming lines. See REGEX_INPUT
    and the corresponding input format example.
    """
    def __init__(self, service, target, flag):
        """
        :type service: str
        :type target: str
        :type flag: str
        """
        self.service = service
        self.target = target
        self.flag = flag
        self.timestamp = int(time.time())


@scope_logger
class ExploitDB():
    """
    An interface to the database. It provides methods to add/remove exploits and
    exploit runs and also for storing new flags in the database.
    """
    def __init__(self):
        try:
            # TODO: one time connect instead of every instance?
            self.mongo = motor.motor_asyncio.AsyncIOMotorClient()
            self.exploitdb = self.mongo.exploitservice
            self.col_expl = self.exploitdb.exploits
            self.col_runs = self.exploitdb.runs
            self.col_targets = self.exploitdb.targets
            self.flagdb = self.mongo.flagservice
            self.col_flags = self.flagdb.flags
            # self.setup_database_indexes()
        except Exception as e:
            self.log.error('Error in ExploitDB().__init__() [EXCEPTION %s]', str(e))

    @classmethod
    async def create(cls):
        obj = cls()
        await obj.setup_database_indexes()
        return obj

    async def setup_database_indexes(self):
        """Speed up find queries by creating indexes."""
        await self.col_flags.create_index([('flag', pymongo.ASCENDING)])

    async def insert_new_flag(self, flag):
        """Insert a new flag if it does not already exist, set status to NEW."""
        try:
            return self.col_flags.update(
                {'flag': flag.flag},
                {'$setOnInsert':
                    {
                        'service': flag.service,
                        'target': flag.target,
                        'flag': flag.flag,
                        'state': 'NEW',
                        'comment': '',
                        'timestamp': int(time.time()),
                        'submitted': 0
                    }
                },
                upsert=True
            )
        except Exception as e:
            self.log.debug(e)

    def select_exploits(self, limit=0):
        try:
            return self.col_expl.find(limit=limit)
        except Exception as e:
            self.log.debug(e)

    def select_exploits_enabled(self):
        try:
            return self.col_expl.find({'enabled': True})
        except Exception as e:
            self.log.debug(e)

    def select_services(self, limit=0):
        try:
            return self.col_expl.distinct('port')
        except Exception as e:
            self.log.debug(e)

    def select_alive_targets(self):
        try:
            return self.col_targets.find({'alive': True})
        except Exception as e:
            self.log.debug(e)

    async def update_exploit(self, service, exploit, port, enabled):
        """Enable/Disable and exploit. If the exploit does not exists, it will be created."""
        try:
            ret = await self.col_expl.update(
                    {
                        'service': service,
                        'exploit': exploit,
                        'port': port
                    },
                    {
                        '$set':
                        {
                            'service': service,
                            'exploit': exploit,
                            'port': port,
                            'enabled': enabled
                        }
                    }, upsert=True)
            return ret
        except Exception as e:
            self.log.debug(e)

    async def insert_run(self, service, exploit, target, port, state, started, finished):
        try:
            return await self.col_runs.insert({
                'service': service,
                'exploit': exploit,
                'target': target,
                'port': port,
                'state': state,
                'started': started,
                'finished': finished
            })
        except Exception as e:
            self.log.debug(e)

    async def exploit_stats(self):
        """Print available exploit, just for test purposes."""
        try:
            exploits = await self.select_exploits().count()
            exploits_enabled = await self.select_exploits_enabled().count()
            self.log.log(LOG_LEVEL_STAT, '[EXPLOITS] [AVAILABLE %d] [ENABLED %d]', exploits, exploits_enabled)
        except Exception as e:
            self.log.debug(e)
