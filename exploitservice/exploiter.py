import time
import txmongo
from datetime import datetime
from twisted.internet import reactor, defer, protocol
from twisted.internet.task import LoopingCall

SERVICE_MONGO_POOLSIZE = 100
targets = ['10.42.1.5', '10.51.1.5', '10.63.1.5'] * 40


class ExploitDB():
    def __init__(self):
        try:
            self.mongo = txmongo.lazyMongoConnectionPool(pool_size=SERVICE_MONGO_POOLSIZE)
            self.db = self.mongo.exploitservice
            self.col_expl = self.db.exploits
            self.col_runs = self.db.runs
        except Exception as e:
            pass

    @defer.inlineCallbacks
    def select_exploits(self, limit=0):
        docs = yield self.col_expl.find(limit=limit)
        defer.returnValue(docs)

    @defer.inlineCallbacks
    def insert_run(self, service, exploit, ip, port, timestamp, success):
        yield self.col_runs.insert({
            'service': service,
            'exploit': exploit,
            'ip': ip,
            'port': port,
            'timestamp': timestamp,
            'success': success
        })

    @defer.inlineCallbacks
    def update_exploit(self, service, exploit, ip, port, enabled):
        yield self.col_expl.update(
                {
                    'service': service,
                    'exploit': exploit,
                    'ip': ip,
                    'port': port
                },
                {
                    '$set':
                    {
                        'service': service,
                        'exploit': exploit,
                        'ip': ip,
                        'port': port,
                        'enabled': enabled
                    }
                }, upsert=True)


class ExploitWorkerProtocol(protocol.ProcessProtocol):
    """An instance of this protocol represents a single instance
    of a running exploit. It allows to specify routines and 
    callbacks based on the exploit behaviour."""

    def __init__(self):
        self.process_started = None

    def connectionMade(self):
        # TODO: If we need to write something into stdin
        #self.transport.write()
        self.pid = self.transport.pid
        self.process_started = int(time.time())

        print('starting job at {}'.format(int(time.time())))

    def outReceived(self, data):
        # TODO: Receive data from stdout, in large chunks
        # TODO: Should apply flag regex here like in the receiver
        print(data)

    def errReceived(self, data):
        # TODO: Receive data from stderr
        pass

    def processExited(self, reason):
        print('finished job at {}'.format(int(time.time())))
	
    def processEnded(self, status):
        # TODO: Last call of ProcessProtocol, maybe add something here
        pass


class Supervisor(LoopingCall):
    """The supervisor manages all running exploit instances."""

    def __init__(self, exploit_db, *args, **kwargs):
        super(Supervisor, self).__init__(self.supervisor_callback, *args, **kwargs)
        print('Started supervisor...')
        self.exploit_db = exploit_db
	self.running_processes = {}

    def start_exploit(self, service, exploit, ip, port):
        # start exploit runner if not already started
	protocol = ExploitWorkerProtocol()
	protocol.deferred = defer.Deferred()

	exploit_cmd = [exploit, ip, str(int(port))]
	process = reactor.spawnProcess(protocol, exploit_cmd[0], exploit_cmd, {})
	self.running_processes[process.pid] = process
	return protocol.deferred

    def stop_exploit(self, service, exploit, ip, port):
        # stop exploit runner if not already stopped
        raise NotImplementedError()

    def exploit_callback(self, service, exploit, ip, port, success):
        self.exploit_db.insert_run(service, exploit, ip, port, datetime.now(), success)

    def exploit_failed_callback(self, service, exploit, ip, port):
        # log failed exploit for stats
        self.exploit_callback(service, exploit, ip, port, False)

    def exploit_success_callback(self, service, exploit, ip, port):
        # log succeded exploit for stats
        self.exploit_callback(service, exploit, ip, port, True)

    def expand_targets(self, exploit):
        # TODO: Add routine to get the current target list
        for target in targets:
            # TODO: Improve handling of running exploits
            _exploit = self.start_exploit(exploit['service'],
                               exploit['exploit'],
                               target,
                               exploit['port'])

      	    _exploit.addCallback(self.exploit_success_callback)
	    _exploit.addErrback(self.exploit_failed_callback)

    @defer.inlineCallbacks
    def supervisor_callback(self):
        print('Started callback')
        exploits = yield self.exploit_db.select_exploits()
        
        print(exploits)

        for exploit in exploits:
            if exploit['enabled']:
                self.expand_targets(exploit)
            else:
                # TODO: Implement
                self.stop_exploit(exploit['service'],
                                  exploit['exploit'],
                                  exploit['port'])


@defer.inlineCallbacks
def print_exploits(exploit_db):
    exploits = yield exploit_db.select_exploits()
    print(exploits)


def run_exploitservice():
    try:
        exploit_db = ExploitDB()

        looper = LoopingCall(print_exploits, exploit_db)
        looper.start(2)

        supervisor = Supervisor(exploit_db=exploit_db)
        supervisor.start(2)

        reactor.run()
    except KeyboardInterrupt:
        reactor.stop()
        sys.exit(0)
    except Exception as e:
        print(e)
        sys.exit(1)

if __name__ == '__main__':
    run_exploitservice()
