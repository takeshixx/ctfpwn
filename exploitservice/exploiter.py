import txmongo
from twisted.internet.task import LoopingCall
from twisted.internet import defer
from datetime import datetime


SERVICE_MONGO_POOLSIZE = 100


class ExploitDB():
    def __init__(self):
        try:
            self.mongo = txmongo.lazyMongoConnectionPool(pool_size=SERVICE_MONGO_POOLSIZE)
            self.db = self.mongo.exploitservice
            self.col_expl = self.db.exploits
            self.col_runs = self.db.runs
        except Exception as e:
            pass

    @defer.inlineCallbacks
    def select_exploits(self, limit=0):
        docs = yield self.col_expl.find(limit=limit)
        defer.returnValue(docs)

    @defer.inlineCallbacks
    def insert_run(self, service, exploit, ip, port, timestamp, success):
        yield self.col_runs.insert({
            'service': service,
            'exploit': exploit,
            'ip': ip,
            'port': port,
            'timestamp': timestamp,
            'success': success
        })

    @defer.inlineCallbacks
    def update_exploit(self, service, exploit, ip, port, enabled):
        yield self.col_expl.update(
                {
                    'service': service,
                    'exploit': exploit,
                    'ip': ip,
                    'port': port
                },
                {
                    '$set':
                    {
                        'service': service,
                        'exploit': exploit,
                        'ip': ip,
                        'port': port,
                        'enabled': enabled
                    }
                }, upsert=True)


class Supervisor(LoopingCall):
    def __init__(self, exploit_db, *args, **kwargs):
        super(Supervisor, self).__init__(self.callback, *args, **kwargs)
        self.exploit_db = exploit_db

    def start_exploit(self, service, exploit, ip, port):
        # start exploit runner if not already started
        raise NotImplementedError()

    def stop_exploit(self, service, exploit, ip, port):
        # stop exploit runner if not already stopped
        raise NotImplementedError()

    def exploit_callback(self, service, exploit, ip, port, success):
        self.exploit_db.insert_run(service, exploit, ip, port, datetime.now(), success)

    def exploit_failed_callback(self, service, exploit, ip, port):
        # log failed exploit for stats
        self.exploit_callback(service, exploit, ip, port, False)

    def exploit_success_callback(self, service, exploit, ip, port):
        # log succeded exploit for stats
        self.exploit_callback(service, exploit, ip, port, True)

    def callback(self):
        exploits = yield self.exploit_db.select_exploits()

        for exploit in exploits:
            if exploit['enabled']:
                self.start_exploit(exploit['service'],
                                   exploit['exploit'],
                                   exploit['ip'],
                                   exploit['port'])
            else:
                self.stop_exploit(exploit['service'],
                                  exploit['exploit'],
                                  exploit['ip'],
                                  exploit['port'])
