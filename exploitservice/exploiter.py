import sys
import re
import random
import time
import txmongo
from datetime import datetime
from twisted.internet import reactor, defer, protocol, utils
from twisted.internet.task import LoopingCall

SERVICE_MONGO_POOLSIZE = 100
targets = ['10.42.1.5', '10.51.1.5', '10.63.1.5'] * 30 

MAX_CONCURRENT = 10

GAME_START = 1448100000
NETWORK_OPEN = GAME_START + 3600
CTF_TICK = 120


# Flag regex
# Input format example: 'smartgrid|10.23.103.2|JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=|1446295211'
REGEX_FLAG = r"(\w{31}=)"
REGEX_SERVICE = r"(\w+)"
REGEX_IP = r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"
REGEX_TIMESTAMP = r"(\d{10})"
REGEX_INPUT = '^{}\|{}\|{}\|{}$'.format(
    REGEX_SERVICE,
    REGEX_IP,
    REGEX_FLAG,
    REGEX_TIMESTAMP
)

input_validation = re.compile(REGEX_INPUT)


class Flag():
    """
    A class that represents flags, as parsed from incoming lines. See REGEX_INPUT
    and the corresponding input format example.
    """
    def __init__(self,incoming):
        self.service = incoming[0]
        self.target = incoming[1]
        self.flag = incoming[2]
        self.timestamp = int(time.time())


class ExploitDB():
    def __init__(self):
        try:
            self.mongo = txmongo.lazyMongoConnectionPool(pool_size=SERVICE_MONGO_POOLSIZE)
            self.exploitdb = self.mongo.exploitservice
            self.col_expl = self.exploitdb.exploits
            self.col_runs = self.exploitdb.runs
            self.fagdb = self.mongo.flagservice
            self.col_flags = self.flagdb.flags
        except Exception as e:
            pass


    @defer.inlineCallbacks
    def insert_new_flag(self, flag):
        """Insert a new flag if it does not already exist, set status to NEW."""
        try:
            yield self.col_flags.update_one(
                {'flag': flag.flag},
                {'$setOnInsert':
                    {
                        'service': flag.service,
                        'target': flag.target,
                        'flag': flag.flag,
                        'state': 'NEW',
                        'comment': '',
                        'timestamp': int(time.time()),
                        'submitted': 0
                    }
                },
                upsert=True
            )
        except Exception as e:
            print(e)

    @defer.inlineCallbacks
    def select_exploits(self, limit=0):
        docs = yield self.col_expl.find(limit=limit)
        defer.returnValue(docs)

    @defer.inlineCallbacks
    def insert_run(self, service, exploit, ip, port, timestamp, success):
        # TODO: Probably add PID
        yield self.col_runs.insert({
            'service': service,
            'exploit': exploit,
            'ip': ip,
            'port': port,
            'timestamp': int(time.time()),
            'success': success
        })

    @defer.inlineCallbacks
    def update_exploit(self, service, exploit, ip, port, enabled):
        yield self.col_expl.update(
                {
                    'service': service,
                    'exploit': exploit,
                    'ip': ip,
                    'port': port
                },
                {
                    '$set':
                    {
                        'service': service,
                        'exploit': exploit,
                        'ip': ip,
                        'port': port,
                        'enabled': enabled
                    }
                }, upsert=True)


class Supervisor(LoopingCall):
    """The supervisor manages all running exploit instances."""

    def __init__(self, db, *args, **kwargs):
        super(Supervisor, self).__init__(self.supervisor_callback, *args, **kwargs)
        self.db = db
        self.sem = defer.DeferredSemaphore(MAX_CONCURRENT)

    def start_exploit(self, service, exploit, ip, port):
        # start exploit runner if not already started
        process = utils.getProcessOutput(exploit, args=[ip, str(int(port))])
      	process.addCallback(self.exploit_success_callback)
	process.addErrback(self.exploit_failed_callback)

    def stop_exploit(self, service, exploit, ip, port):
        # stop exploit runner if not already stopped
        raise NotImplementedError()

    def exploit_failed_callback(self, *args, **kwargs):
        # log failed exploit for stats
        print('Seems like an error happened in the exploit')

    def exploit_success_callback(self, incoming):
        # Print flags here, directly put them into the database
        try:
            lines = incoming.split('\n')
            for line in lines:
                if not line:
                    continue
                line = line.strip()
                if input_validation.findall(line):
                    flag = Flag(line.strip().split('|'))
                    self.db.insert_new_flag(flag)
		    print('Added flag {}'.format(flag.flag))
                    print(dir(flag))
                else:
		    # No valid flags, add info to db
		    pass
        except Exception as e:
	    pass

    def expand_targets(self, exploit):
        # TODO: Add routine to get the current target list
        for target in targets:
            # TODO: Improve handling of running exploits
            self.sem.run(self.start_exploit, exploit['service'], exploit['exploit'], target, exploit['port'])

    @defer.inlineCallbacks
    def supervisor_callback(self):
        """Queue exploits for execution."""
        print('Started callback')
        exploits = yield self.db.select_exploits()
        
        for exploit in exploits:
            #if len(self.running_processes) >= MAX_CONCURRENT:
            #    return
            if exploit['enabled']:
                self.expand_targets(exploit)
            else:
                # TODO: Implement
                self.stop_exploit(exploit['service'],
                                  exploit['exploit'],
                                  exploit['port'])


@defer.inlineCallbacks
def print_exploits(exploit_db):
    exploits = yield exploit_db.select_exploits()
    print(exploits)


def run_exploitservice():
    try:
        exploit_db = ExploitDB()

        looper = LoopingCall(print_exploits, exploit_db)
        looper.start(8)

        supervisor = Supervisor(db=exploit_db)
        supervisor.start(3)

        reactor.run()
    except KeyboardInterrupt:
        reactor.stop()
        sys.exit(0)
    except Exception as e:
        print(e)
        sys.exit(1)

if __name__ == '__main__':
    run_exploitservice()
