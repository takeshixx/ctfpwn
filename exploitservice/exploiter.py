import sys
import os
import signal
import re
import time
import StringIO
import ipaddress
from twisted.internet import reactor, defer, protocol, utils
from twisted.internet.task import LoopingCall
import twisted.internet.error
from twisted.python import log

from .tinylogs import log
from .exploitdb import ExploitDB, Flag

DEBUG = True

# The network range where teams are located, needs to be adjusted
CTF_NETWORK = u'10.1.2.0/26'

# Maximum amount of concurrent running exploits
MAX_CONCURRENT = 10

# Start of the CTF (November 21, 2015 at 10:00 UTC)
GAME_START = 1448100000

# The time when the network should be open (1hour after CTF has started)
NETWORK_OPEN = GAME_START + 60 * 60

# A CTF round will be ~2min
CTF_TICK = 60 * 2

# Check alive hosts every x minutes
CTF_TARGET_ALIVE_INTERVAL = 60 * 3

STATS_INTERVAL = 8
SUPERVISOR_INTERVAL = 12

# If an exploit is still running after x seconds, kill it with fire!
KILL_EXPLOIT_AFTER = 60

SUPERVISOR_CLEAN_WORKERS_INTERVAL = 60

# Global instance to grep for flags, e.g.JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=
FLAG_GREP = re.compile(r"(\w{31}=)")


# TODO: Maybe implement alive checks in separate class/LoopingCall
class Target():
    """
    An instance represents a single target system. It should provide
    information if the host is alive (pingable) and which service
    ports are open.
    """
    def __init__(self, host):
        self.host = host
        self.is_alive = False
        self.services_alive = []


class ExploitWorkerProtocol(protocol.ProcessProtocol):
    """
    An instance of this protocol represents a single instance
    of a running exploit. It allows to specify routines and
    callbacks based on the exploit behaviour.
    """
    def __init__(self, deferred):
        self.deferred = deferred
        self.exploit_output = StringIO.StringIO()

    def connectionMade(self):
        self.pid = self.transport.pid

    def stop(self):
        log.debug('stopping {}'.format(self.pid))
        if self.transport.pid:
            deferred = defer.Deferred()
            self.transport.signalProcess(signal.SIGTERM)
            reactor.callLater(5, self.kill)
            return deferred

        return defer.succeed(None)

    def kill(self):
        log.debug('killing {}'.format(self.pid))
        if self.transport.pid:
            self.transport.signalProcess(signal.SIGKILL)

    def outReceived(self, data):
        self.exploit_output.write(data)

    def errReceived(self, data):
        pass

    def processExited(self, reason):
        pass

    def processEnded(self, reason):

        if self.deferred is not None:
            self.deferred.callback(self.exploit_output.getvalue())
        elif self.onProcessEnded is not None:
            self.onProcessEnded.errback(reason)


class Supervisor(LoopingCall):
    """
    The supervisor manages all running exploit instances.
    """
    def __init__(self, db, *args, **kwargs):
        super(Supervisor, self).__init__(self.supervisor_callback, *args, **kwargs)
        self.db = db
        self.sem = defer.DeferredSemaphore(MAX_CONCURRENT)
        self.running_exploits = {}

    def start_exploit(self, service, exploit, target, port):
        """
        Start an exploit worker process.
        """
        deferred = defer.Deferred()
        protocol = ExploitWorkerProtocol(deferred)

        cmd = [exploit, target, str(int(port))]
        process = reactor.spawnProcess(protocol, cmd[0], cmd, {})
        process_started = int(time.time())

        # Safe some information in an instance variable, might be useful at some point in time.
        self.running_exploits[process.pid] = {'process': process, 'started': process_started}

        # Add callback function which will be called when the exploits ran successfully.
        deferred.addCallback(
            self.exploit_success_callback,
            process.pid,
            service,
            exploit,
            target,
            port,
            process_started
        )
        # Add an error callback that will be called when the exploit did not finish successful.
        # This will be called e.g. when the exploit fails to properly catch exceptions.
        deferred.addErrback(
            self.exploit_failed_callback,
            process.pid,
            service,
            exploit,
            target,
            port,
            process_started
        )
        # Kill exploits after KILL_EXPLOIT_AFTER seconds.
        reactor.callLater(KILL_EXPLOIT_AFTER, self.stop_exploit, process)

    def stop_exploit(self, process):
        """
        Stop an exploit worker process if it's not already finished.
        """
        if not process.pid:
            return

        try:
            process.signalProcess(signal.SIGKILL)
            self.running_exploits.pop(process.pid, None)
        except twisted.internet.error.ProcessExitedAlready:
            return
        except OSError:
            log.debug('Killing {} failed!'.format(process.pid))

    def exploit_failed_callback(self, reason, pid, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        This callback will be called when there was an error during the
        execution of an exploit. It will just add a run to the database
        with state FAILED.
        """
        self.running_exploits.pop(pid, None)
        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'FAILED', exploit_started, exploit_finished)

        log.warning('\033[1;1m[\033[0m\033[96m{}\033[0m\033[1;1m]\033[0m [\033[1;1mEXPLOIT\033[0m {}] [\033[1;1mFAILED\033[0m {}]'.format(
            service,
            exploit,
            reason
        ))

    def exploit_success_callback(self, output, pid, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        The callback that will be called when a exploits has been executed
        without errors. Once the output (STDOUT) contains flags, they
        will be added to the database.
        """
        self.running_exploits.pop(pid, None)

        if (not len(self.running_exploits) % 10):
            log.info('[\033[1;35mQUEUE\033[0m] [\033[1;32mRUNNING\033[0m \033[1;1m{}\033[0m]'.format(len(self.running_exploits)))

        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'SUCCESS', exploit_started, exploit_finished)

        if FLAG_GREP.findall(output):
            for flag in FLAG_GREP.findall(output):
                if not flag:
                    continue

                _flag = Flag(service, target, flag)
                self.db.insert_new_flag(_flag)
        else:
            log.warning('\033[1;1m[\033[0m\033[96m{}\033[0m\033[1;1m]\033[0m [\033[93mNO FLAGS RETURNED\033[0m] [\033[1;1mEXPLOIT\033[0m {}]'.format(
                service,
                exploit
            ))

    def supervisor_cleaner(self):
        """
        Periodically clean the running PIDs. This function will be called each SUPERVISOR_CLEAN_WORKERS_INTERVAL
        seconds.
        """
        for pid in self.running_exploits.keys():
            try:
                os.kill(pid, 0)
            except OSError:
                self.running_exploits.pop(pid, None)

    @defer.inlineCallbacks
    def supervisor_callback(self):
        """
        This function will be called periodically to queue execution
        of all available exploits.
        """
        log.info('[\033[1;35mQUEUE\033[0m] [\033[93msupervisor_callback()\033[0m]')
        if len(self.running_exploits):
            log.info('[\033[1;35mQUEUE\033[0m] [STILL RUNNING EXPLOIT PROCESSES {}]'.format(len(self.running_exploits)))

        exploits = yield self.db.select_exploits()

        if not exploits:
            return

        deferreds = []
        services = set()
        for exploit in exploits:
            if exploit['enabled']:
                services.add(exploit['service'])
                targets = self.get_targets_for_service(exploit['port'])

                for target in targets:
                    _sem = self.sem.run(
                        self.start_exploit,
                        exploit['service'],
                        exploit['exploit'],
                        str(target),
                        exploit['port']
                    )
                    deferreds.append(_sem)

        # Log a message whenever a batch of exploits was executed in a new tick.
        dl = defer.DeferredList(deferreds)
        dl.addCallback(self.tick_started, services)

        # Call the cleaner function which removes already exited processes from the self.running_exploits list.
        reactor.callLater(SUPERVISOR_CLEAN_WORKERS_INTERVAL, self.supervisor_cleaner)

    def tick_started(self, results, services):
        if results:
            log.info('[\033[1;35mQUEUE\033[0m] [\033[1;1mADDED\033[0m \033[1;1m{}\033[0m] [\033[1;1mSERVICES\033[0m \033[1;1m{}\033[0m]'.format(len(results), len(services)))

    def get_targets_for_service(self, port):
        """Return a list/generator of targets for the given service/port."""
        # TODO: Do something useful. If not, just try the whole CTF range

        if True:
            network = ipaddress.ip_network(CTF_NETWORK)
            return network.hosts()

    @defer.inlineCallbacks
    def poll_services_alive(self):
        #services = yield self.db.select_services()
        raise NotImplementedError()

    def check_hosts_alive(self):
        """Update list of alive (pingable) hosts."""
        raise NotImplementedError()

    def check_service_alive(self, target, port):
        """Check a single service if it's alive (port is open)."""
        raise NotImplementedError()


def run_exploitservice():
    try:
        exploit_db = ExploitDB()

        looper = LoopingCall(exploit_db.exploit_stats)
        looper.start(STATS_INTERVAL)

        supervisor = Supervisor(db=exploit_db)
        supervisor.start(SUPERVISOR_INTERVAL)

        reactor.run()
    except KeyboardInterrupt:
        reactor.stop()
        sys.exit(0)
    except Exception as e:
        print(e)
        sys.exit(1)

if __name__ == '__main__':
    run_exploitservice()