import sys
import re
import time
import StringIO
import ipaddress
from twisted.internet import reactor, defer, protocol, utils
from twisted.internet.task import LoopingCall

from .exploitdb import ExploitDB, Flag

# The network range where teams are located, needs to be adjusted
CTF_NETWORK = u'10.1.2.0/26'

# Maximum amount of concurrent running exploits
MAX_CONCURRENT = 10

# Start of the CTF (November 21, 2015 at 10:00 UTC)
GAME_START = 1448100000

# The time when the network should be open (1hour after CTF has started)
NETWORK_OPEN = GAME_START + 60 * 60

# A CTF round will be ~2min
CTF_TICK = 60 * 2

# Check alive hosts every x minutes
CTF_TARGET_ALIVE_INTERVAL = 60 * 3

# Global instance to grep for flags, e.g.JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=
FLAG_GREP = re.compile(r"(\w{31}=)")


# TODO: Maybe implement alive checks in separate class/LoopingCall
class Target():
    """
    An instance represents a single target system. It should provide
    information if the host is alive (pingable) and which service
    ports are open.
    """
    def __init__(self, host):
        self.host = host
        self.is_alive = False
        self.services_alive = []


class ExploitWorkerProtocol(protocol.ProcessProtocol):
    """
    An instance of this protocol represents a single instance
    of a running exploit. It allows to specify routines and
    callbacks based on the exploit behaviour.
    """
    def __init__(self, deferred):
        self.deferred = deferred
        self.exploit_output = StringIO.StringIO()

    def connectionMade(self):
        self.pid = self.transport.pid

    def outReceived(self, data):
        self.exploit_output.write(data)

    def errReceived(self, data):
        pass

    def processExited(self, reason):
        pass

    def processEnded(self, reason):
        if self.deferred is not None:
            self.deferred.callback(self.exploit_output.getvalue())
        elif self.onProcessEnded is not None:
            self.onProcessEnded.errback(reason)


class Supervisor(LoopingCall):
    """
    The supervisor manages all running exploit instances.
    """
    def __init__(self, db, *args, **kwargs):
        super(Supervisor, self).__init__(self.supervisor_callback, *args, **kwargs)
        self.db = db
        self.sem = defer.DeferredSemaphore(MAX_CONCURRENT)

    def start_exploit(self, service, exploit, target, port):
        deferred = defer.Deferred()
        protocol = ExploitWorkerProtocol(deferred)
        cmd = [exploit, target, str(int(port))]
        reactor.spawnProcess(protocol, cmd[0], cmd, {})
        deferred.addCallback(
            self.exploit_success_callback,
            service,
            exploit,
            target,
            port,
            int(time.time())
        )
        deferred.addErrback(
            self.exploit_failed_callback,
            service,
            exploit,
            target,
            port,
            int(time.time())
        )

    def stop_exploit(self, service, exploit, ip, port):
        # stop exploit runner if not already stopped
        raise NotImplementedError()

    def exploit_failed_callback(self, reason, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        This callback will be called when there was an error during the
        execution of an exploit. It will just add a run to the database
        with state FAILED.

        :param reason:
        :param service:
        :param exploit:
        :param target:
        :param port:
        :param exploit_started:
        :param args:
        :param kwargs:
        :return:
        """
        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'FAILED', exploit_started, exploit_finished)

    def exploit_success_callback(self, output, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        The callback that will be called when a exploits has been executed
        without errors. Once the output (STDOUT) contains flags, they
        will be added to the database.

        :param output:
        :param service:
        :param exploit:
        :param target:
        :param port:
        :param exploit_started:
        :param args:
        :param kwargs:
        :return:
        """
        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'SUCCESS', exploit_started, exploit_finished)

        print('Finished exploit for {} in {} seconds'.format(service, exploit_finished-exploit_started))

        for flag in FLAG_GREP.findall(output):
            if not flag:
                continue

            _flag = Flag(service, target, flag)
            self.db.insert_new_flag(_flag)

    @defer.inlineCallbacks
    def supervisor_callback(self):
        """
        This function will be called periodically to queue execution
        of all available exploits.

        :return:
        """
        exploits = yield self.db.select_exploits()
        
        for exploit in exploits:
            if exploit['enabled']:
                targets = self.get_targets_for_service(exploit['port'])

                for target in targets:
                    self.sem.run(
                        self.start_exploit,
                        exploit['service'],
                        exploit['exploit'],
                        str(target),
                        exploit['port']
                    )

    def get_targets_for_service(self, port):
        """Return a list/generator of targets for the given service/port."""
        # TODO: Do something useful. If not, just try the whole CTF range

        if True:
            network = ipaddress.ip_network(CTF_NETWORK)
            return network.hosts()

    @defer.inlineCallbacks
    def poll_services_alive(self):
        #services = yield self.db.select_services()
        raise NotImplementedError()

    def check_hosts_alive(self):
        """Update list of alive (pingable) hosts."""
        raise NotImplementedError()

    def check_service_alive(self, target, port):
        """Check a single service if it's alive (port is open)."""
        raise NotImplementedError()


@defer.inlineCallbacks
def print_exploits(exploit_db):
    """Print available exploit, just for test purposes."""
    exploits = yield exploit_db.select_exploits()
    print(exploits)


def run_exploitservice():
    try:
        exploit_db = ExploitDB()

        looper = LoopingCall(print_exploits, exploit_db)
        looper.start(8)

        supervisor = Supervisor(db=exploit_db)
        supervisor.start(3)

        reactor.run()
    except KeyboardInterrupt:
        reactor.stop()
        sys.exit(0)
    except Exception as e:
        print(e)
        sys.exit(1)

if __name__ == '__main__':
    run_exploitservice()