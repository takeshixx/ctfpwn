import os
import signal
import re
import time
import ipaddress
from twisted.internet import reactor, defer
from twisted.internet.task import LoopingCall
import twisted.internet.error
from twisted.python.filepath import FilePath

from .tinylogs import log
from .exploitdb import Flag
from .worker import ExploitWorkerProtocol

# The network range where teams are located, needs to be adjusted
CTF_NETWORK = u'10.1.2.0/26'

# Start of the CTF (November 21, 2015 at 10:00 UTC)
GAME_START = 1448100000

# The time when the network should be open (1hour after CTF has started)
NETWORK_OPEN = GAME_START + 60 * 60

# A CTF round will be ~2min
CTF_TICK = 60 * 2

# Check alive hosts every x minutes
CTF_TARGET_ALIVE_INTERVAL = 60 * 3

# If an exploit is still running after x seconds, kill it with fire!
KILL_EXPLOIT_AFTER = 60

SUPERVISOR_CLEAN_WORKERS_INTERVAL = 60

# Global instance to grep for flags, e.g.JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=
FLAG_GREP = re.compile(r"(\w{31}=)")

class Supervisor(LoopingCall):
    """
    The supervisor manages all running exploit instances.
    """
    def __init__(self, db, *args, **kwargs):
        super(Supervisor, self).__init__(self.supervisor_callback, *args, **kwargs)
        self.db = db
        self.running_exploits = {}

    def start_exploit(self, service, exploit, target, port):
        """
        Start an exploit worker process.
        """
        deferred = defer.Deferred()
        protocol = ExploitWorkerProtocol(deferred)

        cmd = [exploit, target, str(int(port))]
        process = reactor.spawnProcess(protocol, cmd[0], cmd, {})
        process_started = int(time.time())

        # Safe some information in an instance variable, might be useful at some point in time.
        self.running_exploits[process.pid] = {'process': process, 'started': process_started}

        # Add callback function which will be called when the exploits ran successfully.
        deferred.addCallback(
            self.exploit_success_callback,
            process.pid,
            service,
            exploit,
            target,
            port,
            process_started
        )
        # Add an error callback that will be called when the exploit did not finish successful.
        # This will be called e.g. when the exploit fails to properly catch exceptions.
        deferred.addErrback(
            self.exploit_failed_callback,
            process.pid,
            service,
            exploit,
            target,
            port,
            process_started
        )
        # Kill exploits after KILL_EXPLOIT_AFTER seconds.
        reactor.callLater(KILL_EXPLOIT_AFTER, self.stop_exploit, process)
        return deferred

    def stop_exploit(self, process):
        """
        Stop an exploit worker process if it's not already finished.
        """
        if not process.pid:
            return

        try:
            process.signalProcess(signal.SIGKILL)
            self.running_exploits.pop(process.pid, None)
        except twisted.internet.error.ProcessExitedAlready:
            return
        except OSError:
            log.debug('Killing {} failed!'.format(process.pid))

    def exploit_failed_callback(self, reason, pid, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        This callback will be called when there was an error during the
        execution of an exploit. It will just add a run to the database
        with state FAILED.
        """
        self.running_exploits.pop(pid, None)
        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'FAILED', exploit_started, exploit_finished)

        log.error('[{}] [EXPLOIT {}] [{}]'.format(
            service,
            exploit,
            reason.getErrorMessage()
        ))

    def exploit_success_callback(self, output, pid, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        The callback that will be called when a exploits has been executed
        without errors. Once the output (STDOUT) contains flags, they
        will be added to the database.
        """
        self.running_exploits.pop(pid, None)

        if (not len(self.running_exploits) % 10):
            log.info('[QUEUE] [RUNNING {}]'.format(len(self.running_exploits)))

        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'SUCCESS', exploit_started, exploit_finished)

        if FLAG_GREP.findall(output):
            for flag in FLAG_GREP.findall(output):
                if not flag:
                    continue

                _flag = Flag(service, target, flag)
                self.db.insert_new_flag(_flag)
        else:
            log.error('[{}] [NO FLAGS RETURNED] [EXPLOIT {}]'.format(
                service,
                exploit
            ))

    def supervisor_cleaner(self):
        """
        Periodically clean the running PIDs. This function will be called each SUPERVISOR_CLEAN_WORKERS_INTERVAL
        seconds.
        """
        log.debug('started supervisor_cleaner()')
        for pid in self.running_exploits.keys():
            try:
                os.kill(pid, 0)
            except OSError:
                self.running_exploits.pop(pid, None)

        log.debug('finished supervisor_cleaner()')

    @defer.inlineCallbacks
    def supervisor_callback(self):
        """
        This function will be called periodically to queue execution
        of all available exploits.
        """
        log.debug('started supervisor_callback()')
        t0 = time.time()
        log.info('[QUEUE] [supervisor_callback()]')
        if len(self.running_exploits):
            log.info('[QUEUE] [STILL RUNNING EXPLOIT PROCESSES {}]'.format(len(self.running_exploits)))

        exploits = yield self.db.select_exploits()

        if not exploits:
            log.debug('GOT NO EXPLOITS!')
            return

        deferreds = []
        services = set()
        for exploit in exploits:
            if exploit['enabled']:
                _fp = FilePath(exploit['exploit'])
                if not _fp.isfile():
                    log.error('[EXPLOITS] [Could not find exploit {}]'.format(exploit['exploit']))
                    continue

                services.add(exploit['service'])
                targets = self.get_targets_for_service(exploit['port'])

                for target in targets:
                    _deferred = self.start_exploit(
                        exploit['service'],
                        exploit['exploit'],
                        str(target),
                        exploit['port']
                    )
                    deferreds.append(_deferred)

        # Log a message whenever a batch of exploits was executed in a new tick.
        dl = defer.DeferredList(deferreds)
        dl.addCallback(self.tick_started, services)

        # Call the cleaner function which removes already exited processes from the self.running_exploits list.
        reactor.callLater(SUPERVISOR_CLEAN_WORKERS_INTERVAL, self.supervisor_cleaner)

        log.debug('finished supervisor_callback() took {}'.format(time.time()-t0))

    def tick_started(self, results, services):
        if results:
            log.info('[QUEUE] [ADDED {}] [SERVICES {}]'.format(len(results), len(services)))

    def get_targets_for_service(self, port):
        """Return a list/generator of targets for the given service/port."""
        # TODO: Do something useful. If not, just try the whole CTF range

        if True:
            network = ipaddress.ip_network(CTF_NETWORK)
            return network.hosts()

    @defer.inlineCallbacks
    def poll_services_alive(self):
        #services = yield self.db.select_services()
        raise NotImplementedError()

    def check_hosts_alive(self):
        """Update list of alive (pingable) hosts."""
        raise NotImplementedError()

    def check_service_alive(self, target, port):
        """Check a single service if it's alive (port is open)."""
        raise NotImplementedError()