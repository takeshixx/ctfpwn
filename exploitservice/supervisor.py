import os
import signal
import re
import time
import random
import logging
from twisted.internet import reactor, defer
from twisted.internet.task import LoopingCall
import twisted.internet.error
from twisted.python.filepath import FilePath
from helperlib.logging import scope_logger

from exploitservice.flag import Flag
from .worker import ExploitWorkerProtocol
from .targets import TARGETS

log = logging.getLogger(__name__)

# The network range where teams are located, needs to be adjusted
CTF_NETWORK = '10.60.1.0/23'
CTF_OWN_BOX = '10.60.42.2'

# Maximum amount of concurrent running exploits.
MAX_CONCURRENT_WORKERS = 2048

# Start of the CTF (November 21, 2015 at 10:00 UTC)
GAME_START = 1448100000

# The time when the network should be open (1hour after CTF has started)
NETWORK_OPEN = GAME_START + 60 * 60

# A CTF round will be ~2min
CTF_TICK = 60 * 2

# Check alive hosts every x minutes
CTF_TARGET_ALIVE_INTERVAL = 60 * 3

# If an exploit is still running after x seconds, kill it with fire!
KILL_EXPLOIT_AFTER = 120

SUPERVISOR_CLEAN_WORKERS_INTERVAL = 120

# Global instance to grep for flags, e.g.JAJAJAJAJAJAJAJAJAJAJAJAJAJAJAA=
FLAG_GREP = re.compile(br"(\w{31}=)")


@scope_logger
class Supervisor(LoopingCall):
    """
    The supervisor manages all running exploit instances.
    """
    def __init__(self, db, *args, **kwargs):
        super(Supervisor, self).__init__(self.supervisor_callback, *args, **kwargs)
        self.db = db
        self.sem = defer.DeferredSemaphore(100)
        self.running_exploits = {}

    def start_exploit(self, service, exploit, target, port):
        """
        Start an exploit worker process.
        """
        deferred = defer.Deferred()
        protocol = ExploitWorkerProtocol(deferred)

        cmd = [exploit, target, str(int(port))]
        process = reactor.spawnProcess(protocol, cmd[0], cmd, {})
        process_started = int(time.time())

        # Safe some information in an instance variable, might be useful at some point in time.
        self.running_exploits[process.pid] = {'process': process, 'started': process_started}

        # Add callback function which will be called when the exploits ran successfully.
        deferred.addCallback(
            self.exploit_success_callback,
            process.pid,
            service,
            exploit,
            target,
            port,
            process_started
        )
        # Add an error callback that will be called when the exploit did not finish successful.
        # This will be called e.g. when the exploit fails to properly catch exceptions.
        deferred.addErrback(
            self.exploit_failed_callback,
            process.pid,
            service,
            exploit,
            target,
            port,
            process_started
        )
        # Kill exploits after KILL_EXPLOIT_AFTER seconds.
        reactor.callLater(KILL_EXPLOIT_AFTER, self.stop_exploit, process)
        return deferred

    def stop_exploit(self, process):
        """
        Stop an exploit worker process if it's not already finished.
        """
        if not process.pid:
            return

        try:
            process.signalProcess(signal.SIGKILL)
        except twisted.internet.error.ProcessExitedAlready:
            pass
        except OSError:
            self.log.debug('Killing %d failed!', process.pid)

        self.running_exploits.pop(process.pid, None)

    def exploit_failed_callback(self, reason, pid, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        This callback will be called when there was an error during the
        execution of an exploit. It will just add a run to the database
        with state FAILED.

        :type reason:
        :type pid: int
        :type service: str
        :type exploit: str
        :type target: str
        :type port: int
        :type exploit_started: bool
        """
        self.running_exploits.pop(pid, None)
        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'FAILED', exploit_started, exploit_finished)

        log.error('[%s] [EXPLOIT %s] [%s]',
            service,
            exploit,
            reason.getErrorMessage()
        )

    def exploit_success_callback(self, output, pid, service, exploit, target, port, exploit_started, *args, **kwargs):
        """
        The callback that will be called when a exploits has been executed
        without errors. Once the output (STDOUT) contains flags, they
        will be added to the database.

        :type output: bytes
        :type pid: int
        :type service: str
        :type exploit: str
        :type target: str
        :type port: int
        :type exploit_started: bool
        """
        self.running_exploits.pop(pid, None)

        if (not len(self.running_exploits) % 10):
            self.log.info('[QUEUE] [RUNNING %d]', len(self.running_exploits))

        exploit_finished = int(time.time())
        self.db.insert_run(service, exploit, target, port, 'SUCCESS', exploit_started, exploit_finished)

        # output is bytes here
        if FLAG_GREP.findall(output):
            for flag in FLAG_GREP.findall(output):
                if not flag:
                    continue

                # decode to unicode before inserting flag
                _flag = Flag(service, target, flag.decode('utf-8', errors='replace'))
                self.db.insert_new_flag(_flag)
        else:
            self.log.error('[%s] [NO FLAGS RETURNED] [EXPLOIT %s]',
                service,
                exploit
            )

    def supervisor_cleaner(self):
        """
        Periodically clean the running PIDs. This function will be called each SUPERVISOR_CLEAN_WORKERS_INTERVAL
        seconds.
        """
        self.log.debug('started supervisor_cleaner()')
        for pid in self.running_exploits.keys():
            try:
                os.kill(pid, 0)
            except OSError:
                self.running_exploits.pop(pid, None)

        self.log.debug('finished supervisor_cleaner()')

    @defer.inlineCallbacks
    def supervisor_callback(self):
        """
        This function will be called periodically to queue execution
        of all available exploits.
        """
        self.log.debug('started supervisor_callback()')
        t0 = time.time()
        self.log.info('[QUEUE] [supervisor_callback()]')
        if len(self.running_exploits):
            self.log.info('[QUEUE] [STILL RUNNING EXPLOIT PROCESSES %d]', len(self.running_exploits))

        exploits = yield self.db.select_exploits()
        targets = yield self.get_targets()

        if exploits:
            self.log.info('Found %d exploits', len(exploits))
        else:
            self.log.info('No exploits available')
            return

        if targets:
            self.log.info('Found %d alive targets', len(targets))
        else:
            self.log.info('No alive targets found!')
            return

        random.shuffle(exploits)
        random.shuffle(targets)
        deferred_queue = []
        services = set()
        for exploit in exploits:
            if exploit['enabled']:
                _fp = FilePath(exploit['exploit'])
                if not _fp.isfile():
                    self.log.error('[EXPLOITS] [Could not find exploit %s]', exploit['exploit'])
                    continue

                services.add(exploit['service'])

                for target in targets:
                    deferred_queue.append(self.sem.run(
                        self.start_exploit,
                        exploit['service'],
                        exploit['exploit'],
                        str(target),
                        exploit['port']
                    ))

        # Log a message whenever a batch of exploits was executed in a new tick.
        dl = defer.DeferredList(deferred_queue)
        dl.addCallback(self.tick_started, services)

        # Call the cleaner function which removes already exited processes from the self.running_exploits list.
        reactor.callLater(SUPERVISOR_CLEAN_WORKERS_INTERVAL, self.supervisor_cleaner)

        self.log.debug('finished supervisor_callback() took %f', time.time() - t0)

    def tick_started(self, results, services):
        if results:
            self.log.info('[QUEUE] [ADDED %d] [SERVICES %d]', len(results), len(services))

    @defer.inlineCallbacks
    def get_targets(self):
        """This function should return a list of IP addresses to execute exploits against
        in a new batch."""
        targets = yield self.db.select_alive_targets()

        if targets:
            _targets = []
            for _target in targets:
                _targets.append(_target['host'])
            defer.returnValue(_targets)
        else:
            self.log.info('No alive targets in database, trying full range...')
            defer.returnValue(TARGETS)
